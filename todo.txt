== My refined mission statement for MasterBlaster
In descending order of implementational priority:
* Compiles down to Elf64 assembly
* Strongly functional: abusively wring all business logic out of the parts of the code that handle side effects (Procedures), and then force said logic into pure functions (Lambdas).
* YAGNI: Language is both strict and minimal in order to encourage making impossible or undesirable states unrepresentable.
* Compiler gives gratuitously friendly error messages 
* Less punctuation than Elm
* Maybe one day can cross-compile to other platforms? What do I care. xD

== My original Mission Statement post:
https://discourse.elm-lang.org/t/why-couldnt-elm-or-an-elm-like-language-work-on-the-back-end/2766/23

I originally posted this in a discussion on elm discourse in December 2018. This still does a good job describing my guiding principals writing this new MasterBlaster language.

>>>>>>>>>>
I feel like some things that would be nice to add to and to address in the roadmap explanation as an incentive to want Elm on the back-end would include:

* I want a server side language with a sufficiently powerful and friendly compiler that if my code compiles it’s got exceptionally strong guarantees to be free from code-induced runtime exception.

  I feel like what to do about unavoidable runtime exception for states over long periods of time lays more with the kernel, so maybe an approach like Erlang’s would help for the kernel itself at least: both for handling runtime exceptions and for concurrency.

* I want a compiler both strict and minimal enough to help make impossible or undesirable states unrepresentable.

* I want a purely functional, strongly side-effect controlling language on the back end and I want the compiler to support concentrating all side effects (including talking to network client, talking to disk persistence, managing concurrency, etc) into plugins at the kernel so that those kernel-plugins can be drained of as many moving parts as humanly possible. I want to be able to write a majority of my business logic in a realm where I am guaranteed that every function will return the same output from any given set of inputs every single time: a property which greatly improves caching, lazy evaluation, and the effectiveness of testing.

I’m not aware of any other languages that can offer all three of those guarantees simultaneously (especially the one about YAGNI minimalism), so that represents the Elm-shaped hole that I see in the server-side arena. :slight_smile:
<<<<<<<<<<

== Have so far:
Simple C compiler that can accept a single C function, with no arguments, must be "main", with one statement.
Statement must be "return", expression returned may be a literal integer, or else one of three unary operators prefixing another expression. Thus a linear stack of unaries can be expressed.

== Reverse engineer a C file:
gcc -S -O3 -fno-asynchronous-unwind-tables 01_return2.c

== Compile an s file:
(nasm syntax, not currently being used) nasm -f elf64 -o program.c program.s
(gcc syntax) gcc -m64 program.s program.elf

Now I wish to bend development towards MasterBlaster syntax.

== Ultimate plans:
1. minimal punctuation.
** No curly brace code blocks, though I might allow BEGIN/END keywords. That said Elm already doesn't have any so I probably won't even need that.
** # No List or Record braces, I'll use explicit constructors instead.
*** I am at the very least delaying this goal. I will limit Tuple's to word constructor though.
** Will need periods in method names, like `List.new`.
** Obviously also decimal punctuations. - preceeding a negative number, scientific notation, various common base notations, etc.
** String literal punctuation. I'll accept only apostrophes for single-line literal strings. I will leave double quotes and backticks reserved for future considerations.
** Unlike Elm I think I *would* like to handle template interpolation (like javascript backticks et al), eventually. Implementational details to be decided.
** I might prefer SET/Set keyword or similar over assignment.
** I will probably handle arithmetic and math/logic/boolean/bitwise operators via method invocation as well.
** Primordial function will be a first class procedure named "main". Define it wherever you like, it will be a compiler error for the root of an application to not have one defined.
** For now will accept list of argv, and probably require (my syntactic equivilent of) _ pattern matching until I can even support lists.
** argv.0 (I'll try to support indexing through integer literal methods maybe?) will be the application name, argv.1 and beyond the POSIX arguments.

** About _ pattern matching, I'd like to replace that with a keyword/method as well.
*** Hmm.. `Never`? No.. not until I prove that I can understand that concept.
*** Properties: a variable name that can always be assigned to, but will never actually receive the assignment.. so you can do so as many times as you'd like in the same scope.
*** Pattern matching it in a case statement (and thus all equality tests) always result in a boolean True value.
*** `Wildcard`? `Irrelevant`? `Void`?
*** I'll go with `Wildcard` until a more clear keyword gets made available to me.

** Not certain yet how I'd like to handle capitalization.
*** So far going with "methods are capitalized bouncycaps"
*** Although, record keys becoming methods feel like they might complicate that picture.
*** Unless I make it a less-than-strictly-enforced convention and *encourage* capital bouncy record names?

** I will accept variable names that begin with numbers, if and only if they are referred to in some special way such as the child of a module.
*** That said, how do I plan to support dictionaryVariable.Record if the former is not a Module?

** Question: how will I "Set" a function that accepts arguments? Where does the list of arguments end, and the function body begin?
*** I'll probably have to use parentheses here.
*** That might become unavoidable in grouping simple expressions as well. For example, "defining" a list.. where does that list end?
*** Elm "anonymous function" syntax doesn't help here either, and instead drags to light a different problem:

** I want all functions and variables to be annotated by default
*** There should be an opt-out mechanism, but the opt-out mechanism should make the coder feel like a lazy cheat so that they have motivation to instead either do the right thing to begin with, or loop back around and do the right thing later.
*** User *must* put in some placeholder where the type annotation belongs
*** And then compiler will both chide you and try to derive the type annotation for you simultaneously. So especially lazy devs can place-holder everything up, and then have some utility fill those in if they choose.
*** Annotation only required on assignment.. but that includes record field assignment.

** BUT! .. how am I meant to do this with anonymous functions then? Especially when, for example, anon function gets fed directly as an argument into another function, or any other alternative to a direct variable setting/binding?
*** Also, this fanatacism would require setting up type annotations at the *caller return* of every function, wouldn't it?
*** One idea to consider (not yet sold on, just thought of and also haven't yet been sold against..) type annotation only required at variable bind/set.

** How will I handle I/O and side effects?
*** Elm uses Tea, and kind of abstracts things away beneath their "main" function into core packages.
*** I probably want to do something A LITTLE bit like Haskel, where I have a class of functions that are side effectful, and tainted, and probably live between invocation land and pure function land somehow.
*** I haven't yet decided how I intend to weave that into my `main ([List]argv) = return [Integer]x` primordial procedure, either.
*** Maybe I want to go so far as to *call* a subroutine that deals in side effects some name that is not "function", so that the only things called "function" in my language are the pure ones?
*** Naming decided: Procedure vs Lambda

** Do I want any "tuple" type, or do I want to encapsulate that completely in a kind of function instead? Probably the latter.. I think tuple in Elm and elsewhere is just another function-datatype that has extra sugar.
*** So, I'll have to further research Marie Kondo'ing that sugar.

** I'm toying with making period a valid alias for |>
*** And either period and/or :: for method namespaces.. I cannot decide which to either allow or require.
*** Can I make an imported module namespace be a "function" somehow, so that . == |> becomes a conceptually valid thing to do to it?

** About procedures:
*** Perhaps they can be encapsulated as first class data elements, just as functions are, and then those can be passed into functions as arguments?
*** !!! BUT !!! functions would not be able to invoke them. Only to shuffle them around as symbols.
*** This could allow functions to enforce flow control, even sequentiality, by returning lists of "perform these procedures in this order".
*** In any event, I want to somehow drain 110% of decision making out of the procedures.
*** Current inclination is that, unlike Haskell, I will not use monadic side effects.
*** Instead, I will simply build the compiler to treat procedures differently from functions, and not for example assume that they can be optimized the same way at all.


------------
* Number literal "tests"

* Candidate: at least enough binary digits to describe the bare value
* also at least (number of decimal digits - 1)*3.3 binary digits
* because 3.3 is a sufficiently accurate approximation of log(10)/log(2)

12345678901
11122333334

* 0 = 0->8
* 99 = 8->8
* 100 = 8->8
* 255 = 8->8
* 256 = 8->8
* 1000 = 16->16
* 65535 = 16->16
* 65536 = 16->16
* 100000 = 24->32
* 1000000 = 24->32
* 10000000 = 32->32
* 100000000 = 32->32
* 1000000000 = 40->64
* 4294967295 = 40->64
* 4294967296 = 